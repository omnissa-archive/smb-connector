// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: request.proto

#ifndef PROTOBUF_request_2eproto__INCLUDED
#define PROTOBUF_request_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_request_2eproto();
void protobuf_AssignDesc_request_2eproto();
void protobuf_ShutdownFile_request_2eproto();

class SmbDetails;
class RequestPacket;
class FolderStructureRequest;
class RangeDownloadRequest;
class UploadRequestData;

// ===================================================================

class SmbDetails : public ::google::protobuf::Message {
 public:
  SmbDetails();
  virtual ~SmbDetails();

  SmbDetails(const SmbDetails& from);

  inline SmbDetails& operator=(const SmbDetails& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SmbDetails& default_instance();

  void Swap(SmbDetails* other);

  // implements Message ----------------------------------------------

  SmbDetails* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SmbDetails& from);
  void MergeFrom(const SmbDetails& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string workgroup = 1;
  inline bool has_workgroup() const;
  inline void clear_workgroup();
  static const int kWorkgroupFieldNumber = 1;
  inline const ::std::string& workgroup() const;
  inline void set_workgroup(const ::std::string& value);
  inline void set_workgroup(const char* value);
  inline void set_workgroup(const char* value, size_t size);
  inline ::std::string* mutable_workgroup();
  inline ::std::string* release_workgroup();
  inline void set_allocated_workgroup(::std::string* workgroup);

  // required string username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // required string url = 4;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 4;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional bool kerberos = 5;
  inline bool has_kerberos() const;
  inline void clear_kerberos();
  static const int kKerberosFieldNumber = 5;
  inline bool kerberos() const;
  inline void set_kerberos(bool value);

  // @@protoc_insertion_point(class_scope:SmbDetails)
 private:
  inline void set_has_workgroup();
  inline void clear_has_workgroup();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_kerberos();
  inline void clear_has_kerberos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* workgroup_;
  ::std::string* username_;
  ::std::string* password_;
  ::std::string* url_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_request_2eproto();
  friend void protobuf_AssignDesc_request_2eproto();
  friend void protobuf_ShutdownFile_request_2eproto();

  void InitAsDefaultInstance();
  static SmbDetails* default_instance_;
};
// -------------------------------------------------------------------

class RequestPacket : public ::google::protobuf::Message {
 public:
  RequestPacket();
  virtual ~RequestPacket();

  RequestPacket(const RequestPacket& from);

  inline RequestPacket& operator=(const RequestPacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestPacket& default_instance();

  void Swap(RequestPacket* other);

  // implements Message ----------------------------------------------

  RequestPacket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestPacket& from);
  void MergeFrom(const RequestPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SmbDetails smbDetails = 1;
  inline bool has_smbdetails() const;
  inline void clear_smbdetails();
  static const int kSmbDetailsFieldNumber = 1;
  inline const ::SmbDetails& smbdetails() const;
  inline ::SmbDetails* mutable_smbdetails();
  inline ::SmbDetails* release_smbdetails();
  inline void set_allocated_smbdetails(::SmbDetails* smbdetails);

  // optional .FolderStructureRequest folderStructureRequest = 2;
  inline bool has_folderstructurerequest() const;
  inline void clear_folderstructurerequest();
  static const int kFolderStructureRequestFieldNumber = 2;
  inline const ::FolderStructureRequest& folderstructurerequest() const;
  inline ::FolderStructureRequest* mutable_folderstructurerequest();
  inline ::FolderStructureRequest* release_folderstructurerequest();
  inline void set_allocated_folderstructurerequest(::FolderStructureRequest* folderstructurerequest);

  // optional .RangeDownloadRequest rangeDownloadRequest = 3;
  inline bool has_rangedownloadrequest() const;
  inline void clear_rangedownloadrequest();
  static const int kRangeDownloadRequestFieldNumber = 3;
  inline const ::RangeDownloadRequest& rangedownloadrequest() const;
  inline ::RangeDownloadRequest* mutable_rangedownloadrequest();
  inline ::RangeDownloadRequest* release_rangedownloadrequest();
  inline void set_allocated_rangedownloadrequest(::RangeDownloadRequest* rangedownloadrequest);

  // optional .UploadRequestData uploadRequestData = 4;
  inline bool has_uploadrequestdata() const;
  inline void clear_uploadrequestdata();
  static const int kUploadRequestDataFieldNumber = 4;
  inline const ::UploadRequestData& uploadrequestdata() const;
  inline ::UploadRequestData* mutable_uploadrequestdata();
  inline ::UploadRequestData* release_uploadrequestdata();
  inline void set_allocated_uploadrequestdata(::UploadRequestData* uploadrequestdata);

  // @@protoc_insertion_point(class_scope:RequestPacket)
 private:
  inline void set_has_smbdetails();
  inline void clear_has_smbdetails();
  inline void set_has_folderstructurerequest();
  inline void clear_has_folderstructurerequest();
  inline void set_has_rangedownloadrequest();
  inline void clear_has_rangedownloadrequest();
  inline void set_has_uploadrequestdata();
  inline void clear_has_uploadrequestdata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SmbDetails* smbdetails_;
  ::FolderStructureRequest* folderstructurerequest_;
  ::RangeDownloadRequest* rangedownloadrequest_;
  ::UploadRequestData* uploadrequestdata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_request_2eproto();
  friend void protobuf_AssignDesc_request_2eproto();
  friend void protobuf_ShutdownFile_request_2eproto();

  void InitAsDefaultInstance();
  static RequestPacket* default_instance_;
};
// -------------------------------------------------------------------

class FolderStructureRequest : public ::google::protobuf::Message {
 public:
  FolderStructureRequest();
  virtual ~FolderStructureRequest();

  FolderStructureRequest(const FolderStructureRequest& from);

  inline FolderStructureRequest& operator=(const FolderStructureRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FolderStructureRequest& default_instance();

  void Swap(FolderStructureRequest* other);

  // implements Message ----------------------------------------------

  FolderStructureRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FolderStructureRequest& from);
  void MergeFrom(const FolderStructureRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool showOnlyFolders = 1;
  inline bool has_showonlyfolders() const;
  inline void clear_showonlyfolders();
  static const int kShowOnlyFoldersFieldNumber = 1;
  inline bool showonlyfolders() const;
  inline void set_showonlyfolders(bool value);

  // optional bool showHiddenFiles = 2;
  inline bool has_showhiddenfiles() const;
  inline void clear_showhiddenfiles();
  static const int kShowHiddenFilesFieldNumber = 2;
  inline bool showhiddenfiles() const;
  inline void set_showhiddenfiles(bool value);

  // required uint32 pageSize = 3;
  inline bool has_pagesize() const;
  inline void clear_pagesize();
  static const int kPageSizeFieldNumber = 3;
  inline ::google::protobuf::uint32 pagesize() const;
  inline void set_pagesize(::google::protobuf::uint32 value);

  // optional uint32 level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:FolderStructureRequest)
 private:
  inline void set_has_showonlyfolders();
  inline void clear_has_showonlyfolders();
  inline void set_has_showhiddenfiles();
  inline void clear_has_showhiddenfiles();
  inline void set_has_pagesize();
  inline void clear_has_pagesize();
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool showonlyfolders_;
  bool showhiddenfiles_;
  ::google::protobuf::uint32 pagesize_;
  ::google::protobuf::uint32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_request_2eproto();
  friend void protobuf_AssignDesc_request_2eproto();
  friend void protobuf_ShutdownFile_request_2eproto();

  void InitAsDefaultInstance();
  static FolderStructureRequest* default_instance_;
};
// -------------------------------------------------------------------

class RangeDownloadRequest : public ::google::protobuf::Message {
 public:
  RangeDownloadRequest();
  virtual ~RangeDownloadRequest();

  RangeDownloadRequest(const RangeDownloadRequest& from);

  inline RangeDownloadRequest& operator=(const RangeDownloadRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RangeDownloadRequest& default_instance();

  void Swap(RangeDownloadRequest* other);

  // implements Message ----------------------------------------------

  RangeDownloadRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RangeDownloadRequest& from);
  void MergeFrom(const RangeDownloadRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline ::google::protobuf::uint64 start() const;
  inline void set_start(::google::protobuf::uint64 value);

  // required uint64 end = 2;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 2;
  inline ::google::protobuf::uint64 end() const;
  inline void set_end(::google::protobuf::uint64 value);

  // required uint64 chunkSize = 3;
  inline bool has_chunksize() const;
  inline void clear_chunksize();
  static const int kChunkSizeFieldNumber = 3;
  inline ::google::protobuf::uint64 chunksize() const;
  inline void set_chunksize(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:RangeDownloadRequest)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_chunksize();
  inline void clear_has_chunksize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 start_;
  ::google::protobuf::uint64 end_;
  ::google::protobuf::uint64 chunksize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_request_2eproto();
  friend void protobuf_AssignDesc_request_2eproto();
  friend void protobuf_ShutdownFile_request_2eproto();

  void InitAsDefaultInstance();
  static RangeDownloadRequest* default_instance_;
};
// -------------------------------------------------------------------

class UploadRequestData : public ::google::protobuf::Message {
 public:
  UploadRequestData();
  virtual ~UploadRequestData();

  UploadRequestData(const UploadRequestData& from);

  inline UploadRequestData& operator=(const UploadRequestData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UploadRequestData& default_instance();

  void Swap(UploadRequestData* other);

  // implements Message ----------------------------------------------

  UploadRequestData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UploadRequestData& from);
  void MergeFrom(const UploadRequestData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:UploadRequestData)
 private:
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_request_2eproto();
  friend void protobuf_AssignDesc_request_2eproto();
  friend void protobuf_ShutdownFile_request_2eproto();

  void InitAsDefaultInstance();
  static UploadRequestData* default_instance_;
};
// ===================================================================


// ===================================================================

// SmbDetails

// required string workgroup = 1;
inline bool SmbDetails::has_workgroup() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SmbDetails::set_has_workgroup() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SmbDetails::clear_has_workgroup() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SmbDetails::clear_workgroup() {
  if (workgroup_ != &::google::protobuf::internal::kEmptyString) {
    workgroup_->clear();
  }
  clear_has_workgroup();
}
inline const ::std::string& SmbDetails::workgroup() const {
  return *workgroup_;
}
inline void SmbDetails::set_workgroup(const ::std::string& value) {
  set_has_workgroup();
  if (workgroup_ == &::google::protobuf::internal::kEmptyString) {
    workgroup_ = new ::std::string;
  }
  workgroup_->assign(value);
}
inline void SmbDetails::set_workgroup(const char* value) {
  set_has_workgroup();
  if (workgroup_ == &::google::protobuf::internal::kEmptyString) {
    workgroup_ = new ::std::string;
  }
  workgroup_->assign(value);
}
inline void SmbDetails::set_workgroup(const char* value, size_t size) {
  set_has_workgroup();
  if (workgroup_ == &::google::protobuf::internal::kEmptyString) {
    workgroup_ = new ::std::string;
  }
  workgroup_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SmbDetails::mutable_workgroup() {
  set_has_workgroup();
  if (workgroup_ == &::google::protobuf::internal::kEmptyString) {
    workgroup_ = new ::std::string;
  }
  return workgroup_;
}
inline ::std::string* SmbDetails::release_workgroup() {
  clear_has_workgroup();
  if (workgroup_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = workgroup_;
    workgroup_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SmbDetails::set_allocated_workgroup(::std::string* workgroup) {
  if (workgroup_ != &::google::protobuf::internal::kEmptyString) {
    delete workgroup_;
  }
  if (workgroup) {
    set_has_workgroup();
    workgroup_ = workgroup;
  } else {
    clear_has_workgroup();
    workgroup_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string username = 2;
inline bool SmbDetails::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SmbDetails::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SmbDetails::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SmbDetails::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& SmbDetails::username() const {
  return *username_;
}
inline void SmbDetails::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void SmbDetails::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void SmbDetails::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SmbDetails::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* SmbDetails::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SmbDetails::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 3;
inline bool SmbDetails::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SmbDetails::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SmbDetails::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SmbDetails::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& SmbDetails::password() const {
  return *password_;
}
inline void SmbDetails::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void SmbDetails::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void SmbDetails::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SmbDetails::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* SmbDetails::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SmbDetails::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string url = 4;
inline bool SmbDetails::has_url() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SmbDetails::set_has_url() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SmbDetails::clear_has_url() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SmbDetails::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& SmbDetails::url() const {
  return *url_;
}
inline void SmbDetails::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void SmbDetails::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void SmbDetails::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SmbDetails::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* SmbDetails::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SmbDetails::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool kerberos = 5;
inline bool SmbDetails::has_kerberos() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SmbDetails::set_has_kerberos() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SmbDetails::clear_has_kerberos() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SmbDetails::clear_kerberos() {
  kerberos_ = false;
  clear_has_kerberos();
}
inline bool SmbDetails::kerberos() const {
  return kerberos_;
}
inline void SmbDetails::set_kerberos(bool value) {
  set_has_kerberos();
  kerberos_ = value;
}

// -------------------------------------------------------------------

// RequestPacket

// optional .SmbDetails smbDetails = 1;
inline bool RequestPacket::has_smbdetails() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestPacket::set_has_smbdetails() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestPacket::clear_has_smbdetails() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestPacket::clear_smbdetails() {
  if (smbdetails_ != NULL) smbdetails_->::SmbDetails::Clear();
  clear_has_smbdetails();
}
inline const ::SmbDetails& RequestPacket::smbdetails() const {
  return smbdetails_ != NULL ? *smbdetails_ : *default_instance_->smbdetails_;
}
inline ::SmbDetails* RequestPacket::mutable_smbdetails() {
  set_has_smbdetails();
  if (smbdetails_ == NULL) smbdetails_ = new ::SmbDetails;
  return smbdetails_;
}
inline ::SmbDetails* RequestPacket::release_smbdetails() {
  clear_has_smbdetails();
  ::SmbDetails* temp = smbdetails_;
  smbdetails_ = NULL;
  return temp;
}
inline void RequestPacket::set_allocated_smbdetails(::SmbDetails* smbdetails) {
  delete smbdetails_;
  smbdetails_ = smbdetails;
  if (smbdetails) {
    set_has_smbdetails();
  } else {
    clear_has_smbdetails();
  }
}

// optional .FolderStructureRequest folderStructureRequest = 2;
inline bool RequestPacket::has_folderstructurerequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestPacket::set_has_folderstructurerequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestPacket::clear_has_folderstructurerequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestPacket::clear_folderstructurerequest() {
  if (folderstructurerequest_ != NULL) folderstructurerequest_->::FolderStructureRequest::Clear();
  clear_has_folderstructurerequest();
}
inline const ::FolderStructureRequest& RequestPacket::folderstructurerequest() const {
  return folderstructurerequest_ != NULL ? *folderstructurerequest_ : *default_instance_->folderstructurerequest_;
}
inline ::FolderStructureRequest* RequestPacket::mutable_folderstructurerequest() {
  set_has_folderstructurerequest();
  if (folderstructurerequest_ == NULL) folderstructurerequest_ = new ::FolderStructureRequest;
  return folderstructurerequest_;
}
inline ::FolderStructureRequest* RequestPacket::release_folderstructurerequest() {
  clear_has_folderstructurerequest();
  ::FolderStructureRequest* temp = folderstructurerequest_;
  folderstructurerequest_ = NULL;
  return temp;
}
inline void RequestPacket::set_allocated_folderstructurerequest(::FolderStructureRequest* folderstructurerequest) {
  delete folderstructurerequest_;
  folderstructurerequest_ = folderstructurerequest;
  if (folderstructurerequest) {
    set_has_folderstructurerequest();
  } else {
    clear_has_folderstructurerequest();
  }
}

// optional .RangeDownloadRequest rangeDownloadRequest = 3;
inline bool RequestPacket::has_rangedownloadrequest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestPacket::set_has_rangedownloadrequest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestPacket::clear_has_rangedownloadrequest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestPacket::clear_rangedownloadrequest() {
  if (rangedownloadrequest_ != NULL) rangedownloadrequest_->::RangeDownloadRequest::Clear();
  clear_has_rangedownloadrequest();
}
inline const ::RangeDownloadRequest& RequestPacket::rangedownloadrequest() const {
  return rangedownloadrequest_ != NULL ? *rangedownloadrequest_ : *default_instance_->rangedownloadrequest_;
}
inline ::RangeDownloadRequest* RequestPacket::mutable_rangedownloadrequest() {
  set_has_rangedownloadrequest();
  if (rangedownloadrequest_ == NULL) rangedownloadrequest_ = new ::RangeDownloadRequest;
  return rangedownloadrequest_;
}
inline ::RangeDownloadRequest* RequestPacket::release_rangedownloadrequest() {
  clear_has_rangedownloadrequest();
  ::RangeDownloadRequest* temp = rangedownloadrequest_;
  rangedownloadrequest_ = NULL;
  return temp;
}
inline void RequestPacket::set_allocated_rangedownloadrequest(::RangeDownloadRequest* rangedownloadrequest) {
  delete rangedownloadrequest_;
  rangedownloadrequest_ = rangedownloadrequest;
  if (rangedownloadrequest) {
    set_has_rangedownloadrequest();
  } else {
    clear_has_rangedownloadrequest();
  }
}

// optional .UploadRequestData uploadRequestData = 4;
inline bool RequestPacket::has_uploadrequestdata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestPacket::set_has_uploadrequestdata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestPacket::clear_has_uploadrequestdata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestPacket::clear_uploadrequestdata() {
  if (uploadrequestdata_ != NULL) uploadrequestdata_->::UploadRequestData::Clear();
  clear_has_uploadrequestdata();
}
inline const ::UploadRequestData& RequestPacket::uploadrequestdata() const {
  return uploadrequestdata_ != NULL ? *uploadrequestdata_ : *default_instance_->uploadrequestdata_;
}
inline ::UploadRequestData* RequestPacket::mutable_uploadrequestdata() {
  set_has_uploadrequestdata();
  if (uploadrequestdata_ == NULL) uploadrequestdata_ = new ::UploadRequestData;
  return uploadrequestdata_;
}
inline ::UploadRequestData* RequestPacket::release_uploadrequestdata() {
  clear_has_uploadrequestdata();
  ::UploadRequestData* temp = uploadrequestdata_;
  uploadrequestdata_ = NULL;
  return temp;
}
inline void RequestPacket::set_allocated_uploadrequestdata(::UploadRequestData* uploadrequestdata) {
  delete uploadrequestdata_;
  uploadrequestdata_ = uploadrequestdata;
  if (uploadrequestdata) {
    set_has_uploadrequestdata();
  } else {
    clear_has_uploadrequestdata();
  }
}

// -------------------------------------------------------------------

// FolderStructureRequest

// optional bool showOnlyFolders = 1;
inline bool FolderStructureRequest::has_showonlyfolders() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FolderStructureRequest::set_has_showonlyfolders() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FolderStructureRequest::clear_has_showonlyfolders() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FolderStructureRequest::clear_showonlyfolders() {
  showonlyfolders_ = false;
  clear_has_showonlyfolders();
}
inline bool FolderStructureRequest::showonlyfolders() const {
  return showonlyfolders_;
}
inline void FolderStructureRequest::set_showonlyfolders(bool value) {
  set_has_showonlyfolders();
  showonlyfolders_ = value;
}

// optional bool showHiddenFiles = 2;
inline bool FolderStructureRequest::has_showhiddenfiles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FolderStructureRequest::set_has_showhiddenfiles() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FolderStructureRequest::clear_has_showhiddenfiles() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FolderStructureRequest::clear_showhiddenfiles() {
  showhiddenfiles_ = false;
  clear_has_showhiddenfiles();
}
inline bool FolderStructureRequest::showhiddenfiles() const {
  return showhiddenfiles_;
}
inline void FolderStructureRequest::set_showhiddenfiles(bool value) {
  set_has_showhiddenfiles();
  showhiddenfiles_ = value;
}

// required uint32 pageSize = 3;
inline bool FolderStructureRequest::has_pagesize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FolderStructureRequest::set_has_pagesize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FolderStructureRequest::clear_has_pagesize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FolderStructureRequest::clear_pagesize() {
  pagesize_ = 0u;
  clear_has_pagesize();
}
inline ::google::protobuf::uint32 FolderStructureRequest::pagesize() const {
  return pagesize_;
}
inline void FolderStructureRequest::set_pagesize(::google::protobuf::uint32 value) {
  set_has_pagesize();
  pagesize_ = value;
}

// optional uint32 level = 4;
inline bool FolderStructureRequest::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FolderStructureRequest::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FolderStructureRequest::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FolderStructureRequest::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 FolderStructureRequest::level() const {
  return level_;
}
inline void FolderStructureRequest::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// RangeDownloadRequest

// required uint64 start = 1;
inline bool RangeDownloadRequest::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RangeDownloadRequest::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RangeDownloadRequest::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RangeDownloadRequest::clear_start() {
  start_ = GOOGLE_ULONGLONG(0);
  clear_has_start();
}
inline ::google::protobuf::uint64 RangeDownloadRequest::start() const {
  return start_;
}
inline void RangeDownloadRequest::set_start(::google::protobuf::uint64 value) {
  set_has_start();
  start_ = value;
}

// required uint64 end = 2;
inline bool RangeDownloadRequest::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RangeDownloadRequest::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RangeDownloadRequest::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RangeDownloadRequest::clear_end() {
  end_ = GOOGLE_ULONGLONG(0);
  clear_has_end();
}
inline ::google::protobuf::uint64 RangeDownloadRequest::end() const {
  return end_;
}
inline void RangeDownloadRequest::set_end(::google::protobuf::uint64 value) {
  set_has_end();
  end_ = value;
}

// required uint64 chunkSize = 3;
inline bool RangeDownloadRequest::has_chunksize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RangeDownloadRequest::set_has_chunksize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RangeDownloadRequest::clear_has_chunksize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RangeDownloadRequest::clear_chunksize() {
  chunksize_ = GOOGLE_ULONGLONG(0);
  clear_has_chunksize();
}
inline ::google::protobuf::uint64 RangeDownloadRequest::chunksize() const {
  return chunksize_;
}
inline void RangeDownloadRequest::set_chunksize(::google::protobuf::uint64 value) {
  set_has_chunksize();
  chunksize_ = value;
}

// -------------------------------------------------------------------

// UploadRequestData

// required bytes data = 1;
inline bool UploadRequestData::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UploadRequestData::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UploadRequestData::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UploadRequestData::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& UploadRequestData::data() const {
  return *data_;
}
inline void UploadRequestData::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void UploadRequestData::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void UploadRequestData::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UploadRequestData::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* UploadRequestData::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UploadRequestData::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_request_2eproto__INCLUDED
